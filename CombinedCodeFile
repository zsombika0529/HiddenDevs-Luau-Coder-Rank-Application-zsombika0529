--Server Script Service, "Leaderstats"

local ContentProvider = game:GetService("ContentProvider")
local RS = game:GetService("ReplicatedStorage")
local CashRetreiver = RS.CashRetreiver
local SendVals = RS.SendVals
local BuyingItem = RS.BuyingItem
local CanSeePlayers = RS.CanSeePlayers
local BallSkinSelecting = RS:WaitForChild("BallSkinSelecting")

local DSS = game:GetService("DataStoreService")
local CashDS = DSS:GetDataStore("Cash")

local CashTable = {}

local PriceTable = { --G = Costs Gems, C = Costs Coins, . = Item, ! = Crate.
	BallSkinCrate = "25G!",
	CommonPlinkoTheme = "100000C.",
	CommonPotion = "1000000C."
}

local ImagesTable = { --All of the items' image IDs
	BallSkinCrate = "rbxassetid://77242011109894",
	CommonPlinkoTheme = "rbxassetid://121697505281461",
	CommonPotion = "rbxassetid://17637751963",
	SmoothRed = "rbxassetid://83081996979885",
	SmoothYellow = "rbxassetid://124101355972353",
	SmoothWhite = "rbxassetid://125160088029436",
	SmoothBrown = "rbxassetid://135245582866344",
	ClassicGrey = "rbxassetid://97063688680159",
	BlackMarble = "rbxassetid://77799025248012",
	BronzeMarble = "rbxassetid://76912381811994",
	GrossMarble = "rbxassetid://131724383613299",
	WhiteMarble = "rbxassetid://90216881716216",
	Rust1 = "rbxassetid://116897317688724",
	Rust2 = "rbxassetid://85979031794679",
	Rust3 = "rbxassetid://140128218873968",
	Rust4 = "rbxassetid://75648348548468",
	BloodyBall = "rbxassetid://118844611319134",
	BrownNeon = "rbxassetid://81542463535698",
	GreenNeon = "rbxassetid://113271166489872",
	PinkNeon = "rbxassetid://100135961043608",
	PukeBall = "rbxassetid://113271166489872",
	RedNeon = "rbxassetid://1334395022041449",
	SandBall = "rbxassetid://81521259496800",
	SnowBall = "rbxassetid://135804439049002",
	BlueMetal = "rbxassetid://87253186589944",
	BlueFoil = "rbxassetid://92221039790252",
	CyanMetal = "rbxassetid://104653597627296",
	GreenFoil = "rbxassetid://71921610838778",
	GreenMetal = "rbxassetid://111936388898319",
	PurpleFoil = "rbxassetid://88827627271835",
	YellowMetal = "rbxassetid://74865220120905",
	YellowFoil = "rbxassetid://82744091520648",
	CapsuledCoal = "rbxassetid://121220277074747",
	GreenForcefield = "rbxassetid://99502572209951",
	PinkForcefield = "rbxassetid://85963245088448",
	RedForcefield = "rbxassetid://77811793913912",
	SmoothBlack = "rbxassetid://125075668458760",
	SmoothCyan = "rbxassetid://90103584690996",
	SmoothGreen = "rbxassetid://107381301169800",
	YellowForcefield = "rbxassetid://131207805992599",
	BlueCoin = "rbxassetid://97063688680159",
	BrownCoin = "rbxassetid://97063688680159",
	Developers = "rbxassetid://97063688680159",
	Joelen2010Var1 = "rbxassetid://97063688680159",
	Joelen2010Var2 = "rbxassetid://97063688680159",
	RedCoin = "rbxassetid://97063688680159",
	YellowCoin = "rbxassetid://97063688680159",
	zsombika0529 = "rbxassetid://97063688680159",
	Blackhole = "rbxassetid://97063688680159",
	Carbon = "rbxassetid://97063688680159",
	Chlorophyll = "rbxassetid://97063688680159",
	EarthnMoon = "rbxassetid://97063688680159",
	NeutronStar = "rbxassetid://97063688680159",
	Oxygen = "rbxassetid://97063688680159",
	SolarSystem = "rbxassetid://97063688680159",
	Sulfur = "rbxassetid://97063688680159"
}

local ClassTable = { --3 = Ball skins, Potions = 2, Plinko Themes = 1.
	BallSkinCrate = 3,
	CommonPlinkoTheme = 1,
	CommonPotion = 2,
	SmoothRed = 3,
	SmoothYellow = 3,
	SmoothWhite = 3,
	SmoothBrown = 3,
	ClassicGrey = 3,
	BlackMarble = 3,
	BronzeMarble = 3,
	GrossMarble = 3,
	WhiteMarble = 3,
	Rust1 = 3,
	Rust2 = 3,
	Rust3 = 3,
	Rust4 = 3,
	BloodyBall = 3,
	BrownNeon = 3,
	GreenNeon = 3,
	PinkNeon = 3,
	PukeBall = 3,
	RedNeon = 3,
	SandBall = 3,
	SnowBall = 3,
	BlueMetal = 3,
	BlueFoil = 3,
	CyanMetal = 3,
	GreenFoil = 3,
	GreenMetal = 3,
	PurpleFoil = 3,
	YellowMetal = 3,
	YellowFoil = 3,
	CapsuledCoal = 3,
	GreenGlass = 3,
	PinkGlass = 3,
	RedGlass = 3,
	SmoothBlack = 3,
	SmoothCyan = 3,
	SmoothGreen = 3,
	YellowGlass = 3,
	BlueCoin = 3,
	BrownCoin = 3,
	Developers = 3,
	Joelen2010Var1 = 3,
	Joelen2010Var2 = 3,
	RedCoin = 3,
	YellowCoin = 3,
	zsombika0529 = 3,
	Blackhole = 3,
	Carbon = 3,
	Chlorophyll = 3,
	EarthnMoon = 3,
	NeutronStar = 3,
	Oxygen = 3,
	SolarSystem = 3,
	Sulfur = 3
}

local BallSkins = workspace:WaitForChild("BallSkins")

game.Players.PlayerAdded:Connect(function(Plr) --Starts multiple future commands upon player joining.
	local leaderstats = Instance.new("Folder")
	leaderstats.Parent = Plr
	leaderstats.Name = "leaderstats"

	local CashStr = Instance.new("StringValue")
	CashStr.Parent = leaderstats
	CashStr.Name = "Cash"
	CashStr.Value = 100

	local Cash = Instance.new("IntValue")
	Cash.Parent = Plr
	Cash.Name = 100

	local Gems = Instance.new("IntValue")
	Gems.Name = "Gems"
	Gems.Parent = leaderstats
	Gems.Value = 0

	local Rebirths = Instance.new("IntValue")
	Rebirths.Name = "Rebirths"
	Rebirths.Parent = leaderstats
	Rebirths.Value = 0

	local Timer = Instance.new("IntValue")
	Timer.Parent = Plr.PlayerGui
	Timer.Name = "Timer"
	Timer.Value = 60

	local MoneyCap = Instance.new("IntValue")
	MoneyCap.Parent = Plr.PlayerGui
	MoneyCap.Name = 1e6
	MoneyCap:AddTag("MC")

	local Settings = Instance.new("Folder")
	Settings.Parent = Plr
	Settings.Name = "Settings"

	local PlayersVisible = Instance.new("BoolValue")
	PlayersVisible.Parent = Settings
	PlayersVisible.Name = "PlayersVisible"
	PlayersVisible.Value = true

	local SelectedBallSkin = Instance.new("StringValue")
	SelectedBallSkin.Parent = Settings
	SelectedBallSkin.Name = "SelectedBallSkin"
	SelectedBallSkin.Value = "ClassicGrey"

	local Inventory = Instance.new("Folder")
	Inventory.Parent = Plr
	Inventory.Name = "Inventory"
	--Makes default places to load all Player data, and for future gameplay.
	local Data

	local success, err = pcall(function() --Loads basic player data.
		Data = CashDS:GetAsync(Plr.UserId)

		if Data.SelectedBallSkin ~= nil then
			SelectedBallSkin.Value = Data.SelectedBallSkin
		end
		if Data.Cash == nil or Data.Cash == 0 then
			Cash.Name = 100
			CashStr.Value = 100
			
			if Data.Gems ~= nil and Data.Rebirths ~= 0 then
				Gems.Value = Data.Gems
			end

			if Data.Rebirths ~= nil and Data.Rebirths ~= 0 then --You can only have gems if you've rebirthed before!
				Rebirths.Value = Data.Rebirths
			end
		else
			Cash.Name = math.floor(Data.Cash)
			CashStr.Value = math.floor(Data.Cash)
			
			if Data.Gems ~= nil and Data.Rebirths ~= 0 then
				Gems.Value = Data.Gems
			end

			if Data.Rebirths ~= nil and Data.Rebirths ~= 0 then
				Rebirths.Value = Data.Rebirths
			end
		end
		local BallSkins = workspace:WaitForChild("BallSkins")
		if Data.Inventory then --Checks if Player had previous Themes/Potions/Ball Skins.
			for i, v in pairs(Data.Inventory) do
				local AddItem = Instance.new("StringValue")
				AddItem.Parent = Inventory
				AddItem.Value = v
			end
			for i, v in pairs(BallSkins:WaitForChild("Default"):GetChildren()) do
				--Checks if Player is missing default skins, just in case.
				local Found = false
				for o, b in pairs(Inventory:GetChildren()) do
					if v.Name == b.Value then
						Found = true
					end
				end
				if not Found then
					local AddItem = Instance.new("StringValue")
					AddItem.Parent = Inventory
					AddItem.Value = v.Name
				end
			end
		else --If no previous data then adds default skins into the Player's inventory.
			for i, v in pairs(BallSkins:WaitForChild("Default"):GetChildren()) do 
				--Adds default skins to Player's if no previous data.
				local AddItem = Instance.new("StringValue")
				AddItem.Parent = Inventory
				AddItem.Value = v.Name
			end
		end
			for i, v in pairs(Inventory:GetChildren()) do
				local ImgID = nil
				for o, b in pairs(ImagesTable) do --Goes through the table and finds the skin's picture.
					if o == v.Value then
						ImgID = b
						break
					end
				end
				if ImgID ~= nil then
					local Class = tonumber(ClassTable[v.Value])

					local InventoryUI = Plr:WaitForChild("PlayerGui"):WaitForChild("RightSide"):WaitForChild("Inventory")
					local Inventory2ndClass

					if Class == 1 then --Finds the place to put the loaded item to.
						Inventory2ndClass = InventoryUI.ThemesFrame
					elseif  Class == 2 then
						Inventory2ndClass = InventoryUI.PotionsFrame
					elseif Class == 3 then
						Inventory2ndClass = InventoryUI.SkinsFrame
					end
					if Class == nil or Inventory2ndClass == nil then return end
					local ScrollingFrame = Inventory2ndClass:FindFirstChildOfClass("ScrollingFrame")
					for o, b in pairs(ScrollingFrame:GetChildren()) do --Adds the owned skins into the player's inventory.
						if b:IsA("ImageButton") then
							local Taken = b:FindFirstChildOfClass("BoolValue")
							if not Taken.Value then --If the place in the inventory is free.
								Taken.Value = true
								b:FindFirstChildOfClass("StringValue").Value = v.Value

								local ImageLabel = b:FindFirstChildOfClass("ImageLabel")
								ImageLabel:FindFirstChildOfClass("UIStroke").Enabled = true

								if ImageLabel ~= nil and ImgID then
									ImageLabel.Image = ImgID
								end
								break
							end
						end
					end
				end
			end
	end)
	print(err, success)
	if not success and Data ~= nil then --Kicks if failed to load (doesn't kick if no previous data).
		--task.wait(4)
		print("aaaaa")
		Plr:Kick("Error loading data. Please rejoin and try again.")
		print("Didn't load")
	else --Gives "LoadedSuccessfully" tag if succeeded (Tag needed for many various future functions).
		print("Yea we good")
		Plr:AddTag("LoadedSuccessfully")
	end

	local function CanBuy(Plr, ItemName, ItemClass) --Checks if the player can afford the requested item.
		print("Got it!", ItemName)
		local CashInt = Plr:FindFirstChildOfClass("IntValue", true)
		local Gems = Plr:FindFirstChild("leaderstats", true):FindFirstChild("Gems", true)

		if PriceTable[ItemName] == nil then return "Item Not Found" end
		local PriceString = PriceTable[ItemName]
		print(PriceString, string.gsub(PriceString, "[^%d]", ""), string.gsub(PriceString, "[^%a]", ""))
		local CrateCost = string.gsub(PriceString, "[^%d]", "")
		local CrateCurrency = string.gsub(PriceString, "[^%a]", "")
		local ItemType = string.gsub(PriceString, "[^%.%!]", "")
		local NonSpecifiedCurrencyAmount

		if CrateCurrency == "G" then
			NonSpecifiedCurrencyAmount = Gems.Value
			CrateCurrency = 2
		elseif CrateCurrency == "C" then
			NonSpecifiedCurrencyAmount = CashInt.Name
			CrateCurrency = 1
		end
		
		if tonumber(NonSpecifiedCurrencyAmount) >= tonumber(CrateCost) then
			if CrateCurrency == 1 then
				CashInt.Name -= CrateCost
			elseif CrateCurrency == 2 then
				Gems.Value -= CrateCost
			end
			local InventoryFolder = Plr:WaitForChild("Inventory")
			
			if ItemType == "." then --Adds the normal item into the player's inventory.
				local NewItem = Instance.new("StringValue")
				NewItem.Parent = InventoryFolder
				NewItem.Value = ItemName
			elseif ItemType == "!" then --If ! then it's a crate, rolls the crate.
				local RightSide = Plr:WaitForChild("PlayerGui", 3):WaitForChild("RightSide", 3)
				local AcquiredItem = RightSide:WaitForChild("AcquiredItem", 3)
				local ItemImage = AcquiredItem:WaitForChild("ItemImage", 3)
				local GottenItemName = AcquiredItem:WaitForChild("GottenItemName", 3)
				local ItemRarity = AcquiredItem:WaitForChild("ItemRarity", 3)
				local TimeRemaining = AcquiredItem:WaitForChild("TimeRemaining", 3)
				
				local RandInt = math.random(0, 10000)
				local GottenNum = RandInt/100
				local GottenRarity
				if GottenNum <= 0.5 then
					GottenRarity = "Mythic"
					ItemRarity.TextColor3 = Color3.fromRGB(230, 30, 30)
				elseif GottenNum <= 3 then
					GottenRarity = "Legendary"
					ItemRarity.TextColor3 = Color3.fromRGB(255, 128, 0)
				elseif GottenNum <= 10 then
					GottenRarity = "Epic"
					ItemRarity.TextColor3 = Color3.fromRGB(163, 53, 238)
				elseif GottenNum <= 25 then
					GottenRarity = "Rare"
					ItemRarity.TextColor3 = Color3.fromRGB(0, 112, 221)
				elseif GottenNum <= 50 then
					GottenRarity = "Uncommon"
					ItemRarity.TextColor3 = Color3.fromRGB(30, 255, 0)
				else
					GottenRarity = "Common"
					ItemRarity.TextColor3 = Color3.fromRGB(128, 128, 128)
				end
				local SkinRarityTable = BallSkins:FindFirstChild(GottenRarity):GetChildren()
				local SkinRarityIndex = math.random(1, #SkinRarityTable)
				local OpenedSkin = SkinRarityTable[SkinRarityIndex]
				print(GottenRarity, SkinRarityTable[SkinRarityIndex])
				ItemName = OpenedSkin.Name
				
				AcquiredItem.Visible = true
				
				ItemRarity.Text = GottenRarity
				GottenItemName.Text = OpenedSkin.Name
				ItemImage.Image = ImagesTable[ItemName]
				
				local Inventory = Plr.Inventory
				local AddItem = Instance.new("StringValue")
				AddItem.Parent = Inventory
				AddItem.Value = OpenedSkin.Name
			end

			--[[How to use: Make a new stringval, its value needs to be the item's name.
				Place it in the "InventoryFolder". Then copy the rest of the code.]]

			task.spawn(function() --Puts the item into the player's openable inventory UI.
				local PlrGui = Plr.PlayerGui
				local RightSide = PlrGui.RightSide
				local Inventory = RightSide.Inventory

				local Inventory2ndClass

				if ItemClass == "1" then
					Inventory2ndClass = Inventory.ThemesFrame
				elseif  ItemClass == "2" then
					Inventory2ndClass = Inventory.PotionsFrame
				elseif ItemClass == "3" then
					Inventory2ndClass = Inventory.SkinsFrame
				end
				local ScrollingFrame = Inventory2ndClass:FindFirstChildOfClass("ScrollingFrame")

				for i, v in pairs(ScrollingFrame:GetChildren()) do
					if v:IsA("ImageButton") then
						local Taken = v:FindFirstChildOfClass("BoolValue")
						if not Taken.Value then
							Taken.Value = true
							v:FindFirstChildOfClass("StringValue").Value = ItemName
							local ImageLabel = v:FindFirstChildOfClass("ImageLabel")
							ImageLabel:FindFirstChildOfClass("UIStroke").Enabled = true

							local Img = ImagesTable[ItemName]

							ImageLabel.Image = Img
							break
						end
					end
				end
			end)
			return true, ItemType
		elseif tonumber(NonSpecifiedCurrencyAmount) < tonumber(CrateCost) then
			return false
		end
	end

	BuyingItem.OnServerInvoke = CanBuy

	local PlrGui = Plr.PlayerGui
	local RightSide = PlrGui:WaitForChild("RightSide")
	local Shop = RightSide:WaitForChild("Shop")
	local ShopFrame = Shop:WaitForChild("ShopFrame")
end)

local function SafeSave() --Failsave, saves every players' data every 30s just in case if an error were to occur.
	while true do
		for i, v in pairs(game.Players:GetPlayers()) do
			if v:HasTag("LoadedSuccessfully") then
				local InventoryItems = v:FindFirstChild("Inventory")

				local ExtraCash = 0
				for o, b in pairs(CashTable) do
					if v.Name == b.Name then
						ExtraCash = b.Value
					end
				end

				local DSSTable = {}
				for o, b in pairs(InventoryItems:GetChildren()) do
					table.insert(DSSTable, b.Value)
				end
				local DataToSave = {
					Cash = tonumber(v:FindFirstChildOfClass("IntValue", true).Name) + ExtraCash,
					Rebirths = v:FindFirstChild("leaderstats", true):FindFirstChild("Rebirths").Value,
					Gems = v:FindFirstChild("leaderstats", true):FindFirstChild("Gems", true).Value,
					Inventory = DSSTable --Inventory (skins).
				}
				local success, result = pcall(function()
					return CashDS:UpdateAsync(v.UserId, function(OldData)
						return DataToSave or OldData --If no data to save, then saves the previous data again.
					end)
				end)
				print(result, success, "Saved for: "..v.Name)
			else
				print("Couldn't load.")
			end
		end
		task.wait(10)
	end
end

task.spawn(SafeSave)

SendVals.OnServerEvent:Connect(function(Plr, Value)
	--Puts the player's current money found in balls to save if the player were to suddenly leave.
	local Found = false
	for i, v in pairs(CashTable) do
		if v.Name == Plr.Name then --If already in the table then remove the previous data and readd new data.
			table.remove(CashTable, i)
			table.insert(CashTable, {Name = Plr.Name, Value = Value})
			Found = true
		end
	end
	if Found == false then --If not in the table then just add in normally.
		table.insert(CashTable, {Name = Plr.Name, Value = Value})
	end
end)

CanSeePlayers.OnServerEvent:Connect(function(Plr, Answer) --Turns on or off if the player can see others (out of order).
	local Settings = Plr:FindFirstChild("Settings")
	local PlayersVisible = Settings:FindFirstChild("PlayersVisible")

	if PlayersVisible.Value == true then --To Invis
		PlayersVisible.Value = false
	elseif PlayersVisible.Value == false then --To Vis
		PlayersVisible.Value = true
	end
end)

local success = true

game.Players.PlayerRemoving:Connect(function(Plr) --Saves players' data when they leave the experience.
	local InventoryItems = {}

	for i, v in pairs(Plr.Inventory:GetChildren()) do --Gets all player's inventory items and puts it in a table.
		if v:IsA("StringValue") and v.Value ~= nil then
			table.insert(InventoryItems, v.Value)
		end
	end
	if Plr:HasTag("LoadedSuccessfully") then --If successfully loaded at the beggining of joining then let's the game save.
		local ExtraCash = 0
		for i, v in pairs(CashTable) do
			if v.Name == Plr.Name then
				ExtraCash = v.Value
			end
		end
		local DataToSave = {
			Cash = tonumber(Plr:FindFirstChildOfClass("IntValue", true).Name) + ExtraCash,
			Rebirths = Plr:FindFirstChild("leaderstats", true):FindFirstChild("Rebirths").Value,
			Gems = Plr:FindFirstChild("leaderstats", true):FindFirstChild("Gems", true).Value,
			Inventory = InventoryItems,
			SelectedBallSkin = Plr.Settings.SelectedBallSkin.Value
		}
		local success, result = pcall(function()
			return CashDS:UpdateAsync(Plr.UserId, function(OldData)
				print(DataToSave)
				return DataToSave or OldData --If new data to save then saves, otherwise saves the previous data again.
			end)
		end)
	end
	task.wait()
end)

BallSkinSelecting.OnServerEvent:Connect(function(Plr, SkinName) --Changes the player's selected ball skin upon request.
	for i, v in pairs(Plr.Inventory:GetChildren()) do
		if v.Value == SkinName then
			Plr.Settings.SelectedBallSkin.Value = SkinName
		end
	end
end)


--Server Script Service, "MainScript"

local RS = game:GetService("ReplicatedStorage")
local GiveCash = RS:WaitForChild("GiveCash")
local CashRetreiver = RS:WaitForChild("CashRetreiver")
local SendVals = RS:WaitForChild("SendVals")
local CashDrop = RS:WaitForChild("CashDrop")
local DebrisLaunch = RS:WaitForChild("DebrisLaunch")
local CostDisplayer = RS:WaitForChild("CostDisplayer")
local Rebirthed = RS:WaitForChild("Rebirthed")
local PlayerAdded = RS:WaitForChild("PlayerAdded") --LoadingScreen
local PaymentChecker = RS:WaitForChild("PaymentChecker")
local PurchaseSuccessful = RS:WaitForChild("PurchaseSuccessful")

local Pay = 2500

local Running = false

local HeadUIs = RS:WaitForChild("HeadUIs")
local HeadRankUIs = RS:WaitForChild("HeadRankUIs")
local GroupID = 9048365

local function UpdateValue() --Updates Players' Money On The Leaderboard (Only For Display Purposes).
	while true do
		for i, v in pairs(game.Players:GetPlayers()) do
			local leaderstats = v:FindFirstChild("leaderstats", true)
			local CashStr = leaderstats:FindFirstChildOfClass("StringValue", true)
			local CashInt = v:FindFirstChildOfClass("IntValue", true)

			local cash = tonumber(CashInt.Name)

			if cash >= 1e3 and cash < 1e6 then
				CashStr.Value = math.floor(cash / 1e3).."K"
			elseif cash >= 1e6 and cash < 1e9 then
				CashStr.Value = math.floor(cash / 1e6).."M"
			elseif cash >= 1e9 and cash < 1e12 then
				CashStr.Value = math.floor(cash / 1e9).."B"
			elseif cash >= 1e12 and cash < 1e15 then
				CashStr.Value = math.floor(cash / 1e12).."T"
			elseif cash >= 1e15 and cash < 1e18 then
				CashStr.Value = math.floor(cash / 1e15).."Q"
			elseif cash >= 1e18 and cash < 1e21 then
				CashStr.Value = math.floor(cash / 1e18).."Qu"
			elseif cash >= 1e21 and cash < 1e24 then
				CashStr.Value = math.floor(cash / 1e21).."Sx"
			elseif cash >= 1e24 and cash < 1e27 then
				CashStr.Value = math.floor(cash / 1e24).."Se"
			elseif cash >= 1e27 and cash < 1e30 then
				CashStr.Value = math.floor(cash / 1e27).." Oct"
			elseif cash >= 1e30 and cash < 1e33 then
				CashStr.Value = math.floor(cash / 1e30).."Non"
			elseif cash >= 1e33 and cash < 1e36 then
				CashStr.Value = math.floor(cash / 1e33).."Dec"
			elseif cash >= 1e36 and cash < 1e39 then
				CashStr.Value = math.floor(cash / 1e36).."Und"
			elseif cash >= 1e39 and cash < 1e42 then
				CashStr.Value = math.floor(cash / 1e39).."Duo"
			elseif cash >= 1e42 and cash < 1e45 then
				CashStr.Value = math.floor(cash / 1e42).."Tre"
			elseif cash >= 1e45 and cash < 1e48 then
				CashStr.Value = math.floor(cash / 1e45).."Quat"
			elseif cash >= 1e48 and cash < 1e51 then
				CashStr.Value = math.floor(cash / 1e48).."Qui"
			elseif cash >= 1e51 and cash < 1e54 then
				CashStr.Value = math.floor(cash / 1e51).."Sxd"
			else
				CashStr.Value = math.floor(cash)
			end
		end
		task.wait(0.01)
	end
end

task.spawn(UpdateValue)

local function CashCheck(Player, leaderstats, Cost) --Checks the player's money, if has enough then drops the ball.
	local SelectedSkinName = Player:WaitForChild("Settings"):WaitForChild("SelectedBallSkin").Value
	local SelectedSkin
	if workspace:FindFirstChild("BallSkins", true):FindFirstChild(SelectedSkinName, true) then 
		--Checks for the player's selected skin.
		SelectedSkin = workspace:WaitForChild("BallSkins"):FindFirstChild(SelectedSkinName, true)
	else
		SelectedSkin = workspace:WaitForChild("BallSkins"):FindFirstChild("ClassicGrey", true)
	end
	local Cash = Player:FindFirstChildOfClass("IntValue", true)
	local CashVal = tonumber(Cash.Name)
	if tonumber(Cash.Name) >= Cost then
		if Cost * 1.1 >= tonumber(Cash.Name) then
			Cash.Name -= Cost
			return true, 1, SelectedSkin
		else
			Cash.Name -= Cost
			return true, 0, SelectedSkin
		end
	end
end

CashDrop.OnServerInvoke = CashCheck

GiveCash.OnServerEvent:Connect(function(Plr, Multiplier, Value) 
	--Adds money to the player depending on where the ball lands.
	local Value = Value
	local Multiplier = Multiplier
	local TrueValue = Value * Multiplier

	local leaderstats = Plr:FindFirstChild("leaderstats", true)
	local Cash = Plr:FindFirstChildOfClass("IntValue", true)
	local Rebirths = leaderstats:FindFirstChild("Rebirths")
	if Rebirths.Value == 0 then
		Cash.Name += TrueValue
	else
		Cash.Name += TrueValue + (0.05 * Rebirths.Value * TrueValue)
	end
end)

DebrisLaunch.OnServerEvent:Connect(function(Plr, Val) --If ball didn't reach destination within the given time.
	Plr:FindFirstChildOfClass("IntValue", true).Name += Val
end)

local function RebirthPrices(Plr, Rebirths) --Price of doing a rebirth.
	local ControlNum = 1e6
	local Increment = 1e3^Rebirths
	if Rebirths == 0 then
		return 1e6
	else
		return ControlNum * Increment
	end
end

CostDisplayer.OnServerInvoke = RebirthPrices

local function EinHundert(Plr, Cash)
	for Times = 1, 10, 1 do
		Cash.Name = 100
		task.wait()
	end
end

local function RebirthRequested(Plr) --Fires upon player requesting a rebirth.
	local leaderstats = Plr:FindFirstChild("leaderstats")
	local Cash = Plr:FindFirstChildOfClass("IntValue")
	local Rebirths = leaderstats:FindFirstChild("Rebirths")
	local Gems = leaderstats:FindFirstChild("Gems")

	local ControlNum = 1e6
	local Increment = 1e3^Rebirths.Value

	if Rebirths.Value == 0 then
		if tonumber(Cash.Name) >= 1e6 then
			Rebirths.Value += 1
			Gems.Value += 50
			Cash.Name = 100
			task.spawn(EinHundert, Plr, Cash)
			return true
		end
	end
	if Rebirths.Value > 0 then
		if tonumber(Cash.Name) >= ControlNum * Increment then
			Gems.Value += 50 * Rebirths.Value
			Rebirths.Value += 1
			Cash.Name = 100
			task.spawn(EinHundert, Plr, Cash)
			return true
		end
	end
end

Rebirthed.OnServerInvoke = RebirthRequested

game.Players.PlayerAdded:Connect(function(Plr)
	PlayerAdded:FireClient(Plr) --Loading Screen!
end)

local function PaymentTimer() --Gives free cash to the player every 60s.
	while true do
		for i, v in pairs(game.Players:GetPlayers()) do
			local Timer = v.PlayerGui:WaitForChild("Timer", true)
			local Cash = nil
			if v:FindFirstChildOfClass("IntValue") then
				Cash = v:FindFirstChildOfClass("IntValue")
			end
			if Cash ~= nil then
				if Timer.Value <= 0 then
					Timer.Value = 60
					Cash.Name += Pay
					PaymentChecker:FireClient(v, Timer.Value, Pay)
				else 
					Timer.Value -= 1
					PaymentChecker:FireClient(v, Timer.Value, Pay)
				end
			end
		end
		task.wait(1)
	end
end

task.spawn(PaymentTimer)

local function CapReached() --Checks if the player overgoes their allowed cash limit, changes player's money if more.
	while true do
		local success, err = pcall(function()
			for i, v in pairs(game.Players:GetPlayers()) do
				if v:HasTag("LoadedSuccessfully") then
					local Cash = nil
					if v:FindFirstChildOfClass("IntValue") then
						Cash = v:FindFirstChildOfClass("IntValue")
					end
					if Cash ~= nil then
						local MoneyCap
						for i, v in pairs(v.PlayerGui:GetChildren()) do
							if v:IsA("IntValue") and v:HasTag("MC") then
								MoneyCap = v
							end
						end
						if tonumber(Cash.Name) > tonumber(MoneyCap.Name) then
							Cash.Name = MoneyCap.Name
							print("Changed!"..MoneyCap.Name)
						end
					end
				end
			end
		end)
		task.wait(0.01)
	end
end

local function MaxCash() --Counterpart of CapReached(starts it too, only activates it once, runs 4ever), checks every 5s.
	while true do
		for i, v in pairs(game.Players:GetPlayers()) do
			if v:HasTag("LoadedSuccessfully") then
				local Cash = nil
				if v:FindFirstChildOfClass("IntValue") then
					Cash = v:FindFirstChildOfClass("IntValue")
				end
				if Cash ~= nil then
					local Rebirths = v:WaitForChild("leaderstats"):WaitForChild("Rebirths").Value
					local MoneyCap
					for i, v in pairs(v.PlayerGui:GetChildren()) do
						if v:IsA("IntValue") and v:HasTag("MC") then
							MoneyCap = v
						end
					end
					local ActCap = 1e6 * (1000^Rebirths) --ActCap = "Actual Cap".
					if ActCap == 0 then
						MoneyCap.Name = 1e6
					else
						MoneyCap.Name = ActCap
					end
					if Running == false then
						task.spawn(CapReached)
						Running = true
					end
				end
			end
		end
		task.wait(5)
	end
end

task.spawn(MaxCash)

task.spawn(function() --Adds rank and name UI above every player.
	game.Players.PlayerAdded:Connect(function(Plr)
		Plr.CharacterAdded:Connect(function(Char)
			local UIClone = HeadUIs:Clone()
			UIClone.Parent = Char:WaitForChild("HumanoidRootPart")
			
			local Name = UIClone.User
			Name.Text = Plr.Name
			
			local GroupRank = Plr:GetRankInGroup(GroupID)
			
			for i, v in pairs(HeadRankUIs:GetChildren()) do
				if v:HasTag(GroupRank) then
					local RankClone = v:Clone()
					RankClone.Parent = UIClone
				end
			end
		end)
	end)
end)


--StartGui -> ScriptHolder, "UIManager"

local Player = game.Players.LocalPlayer
local leaderstats = Player:FindFirstChild("leaderstats", true)
local CashStr = leaderstats:FindFirstChildOfClass("StringValue", true)
local Cash = Player:FindFirstChildOfClass("IntValue", true)
local Gems = leaderstats:FindFirstChild("Gems")
local Rebirths = leaderstats:FindFirstChild("Rebirths")
local Settings = Player:FindFirstChild("Settings")
local PlayersVisible = Settings:FindFirstChild("PlayersVisible")

local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local MPS = game:GetService("MarketplaceService")

local Mouse = Player:GetMouse()

local CashDrop = RS:FindFirstChild("CashDrop")
local CostDisplayer = RS:WaitForChild("CostDisplayer")
local Rebirthed = RS:WaitForChild("Rebirthed")
local PlayerAdded = RS:WaitForChild("PlayerAdded")
local BuyingItem = RS:WaitForChild("BuyingItem")
local PaymentChecker = RS:WaitForChild("PaymentChecker")
local PurchaseSuccessful = RS:WaitForChild("PurchaseSuccessful")
local CanSeePlayers = RS:WaitForChild("CanSeePlayers")
local BallSkinSelecting = RS:WaitForChild("BallSkinSelecting")

local PlayerGui = game.Players.LocalPlayer.PlayerGui
local Times = PlayerGui:WaitForChild("Times")
local MainFrame = Times:WaitForChild("MainFrame")
local ButtonsFrames = MainFrame:WaitForChild("ButtonsFrame")
local CustomFrame = MainFrame:WaitForChild("CustomFrame")
local CustomVal = CustomFrame:WaitForChild("CustomVal")

local RightSide = PlayerGui:WaitForChild("RightSide")
local CoinsFrame = RightSide:WaitForChild("CoinsFrame")
local CoinsImage = CoinsFrame:WaitForChild("CoinsImage")
local CoinsAmount = CoinsFrame:WaitForChild("CoinsAmount")
local GemsFrame = RightSide:WaitForChild("GemsFrame")
local GemsImage = GemsFrame:WaitForChild("GemsImage")
local GemsAmount = GemsFrame:WaitForChild("GemsAmount")
local Settings = RightSide:WaitForChild("Settings")
local SettingsFrame = Settings:WaitForChild("SettingsFrame")
local Configuration1 = SettingsFrame:WaitForChild("Configuration1")
local MuteState = Configuration1:WaitForChild("MuteState")
local Muted = MuteState:WaitForChild("Muted")
local Slider = Configuration1:WaitForChild("Slider")
local Object = Slider:WaitForChild("Object")
local CurrentValue = Slider:WaitForChild("CurrentValue")
local Trigger = Slider:WaitForChild("Trigger")
local Go = Slider:WaitForChild("Go")
local VolumePercentage = Configuration1:WaitForChild("VolumePercentage")
local MusicChooser = Configuration1:WaitForChild("MusicChooser")
local MusicsFrame = Configuration1:WaitForChild("MusicsFrame")
local MusicsScroll = MusicsFrame:WaitForChild("MusicsScroll")
local MusicGroup = Settings:WaitForChild("MusicGroup")
local CustomMusicID = Configuration1:WaitForChild("CustomMusicID")
local CustomMusic = MusicGroup:WaitForChild("CustomMusic")
local SettingsButtonFrame = RightSide:WaitForChild("SettingsButtonFrame")
local SettingsOpener = SettingsButtonFrame:WaitForChild("SettingsOpener")
local SettingsExit = Settings:WaitForChild("SettingsExit")
local Configuration2 = SettingsFrame:WaitForChild("Configuration2")
local SeePlayers = Configuration2:WaitForChild("SeePlayers")
local SeePlayersText = Configuration2:WaitForChild("SeePlayersText")
local CanSee = SeePlayers:WaitForChild("CanSee")

local SRebFrame = RightSide:WaitForChild("SRebFrame")
local RFrameOpener = SRebFrame:WaitForChild("RFrameOpener")
local MRebFrame = RightSide:WaitForChild("MRebFrame")
local RebirthFrame = RightSide:WaitForChild("RebirthFrame")
local RebirthButton = RebirthFrame:WaitForChild("RebirthButton")
local Close = MRebFrame:WaitForChild("Close")
local Cost = MRebFrame:WaitForChild("Cost")

local Shop = RightSide:WaitForChild("Shop")
local ShopFrame = Shop:WaitForChild("ShopFrame")
local ShopExit = Shop:WaitForChild("ShopExit")
local ShopButtonFrame = RightSide:WaitForChild("ShopButtonFrame")
local ShopOpener = ShopButtonFrame:WaitForChild("ShopOpener")
local Success = Shop:WaitForChild("Success")
local Fail = Shop:WaitForChild("Fail")
local Warning = RightSide:WaitForChild("Warning")
local Warned = Warning:WaitForChild("Warned")
local WarningText = Warning:WaitForChild("TextLabel")
local PaymentFrame = RightSide:WaitForChild("PaymentFrame")
local PaymentTimer = PaymentFrame:WaitForChild("PaymentTimer")

local InventoryButtonFrame = RightSide:WaitForChild("InventoryButtonFrame")
local InventoryOpener = InventoryButtonFrame:WaitForChild("InventoryOpener")
local Inventory = RightSide:WaitForChild("Inventory")
local InventoryExit = Inventory:WaitForChild("InventoryExit")

local AcquiredItem = RightSide:WaitForChild("AcquiredItem", 3)
local ItemImage = AcquiredItem:WaitForChild("ItemImage", 3)
local GottenItemName = AcquiredItem:WaitForChild("GottenItemName", 3)
local ItemRarity = AcquiredItem:WaitForChild("ItemRarity", 3)
local TimeRemaining = AcquiredItem:WaitForChild("TimeRemaining", 3)

local Drop = PlayerGui:WaitForChild("Drop")
local DropFrame = Drop:WaitForChild("DropFrame")
local AutoDropEnabled = DropFrame.AutoDrop.Enabled
local ID1 = false
local CostInt

while ID1 == false do
	CostInt = DropFrame:FindFirstChildOfClass("IntValue")
	if CostInt ~= nil then ID1 = true end
	task.wait()
end
print("LOADED!")

local Plinko = workspace:WaitForChild("Plinko")
local DownID = Plinko:WaitForChild("DownID")
local UpperID = Plinko:WaitForChild("UpperID")

local Moving = false
local TweenTime = 2

local Val = nil

local InvServ = false

local MusicTable = {}
local MusicRemoved
local Play = true

local UICombineTable = {}

local WarningReq = {}
local WarningOngoing = false
local WarningTime = 3

local MaxLoudness = 100
local OpenSettings = false

local MusicPlaying = false

for i, v in pairs(MusicGroup:GetChildren()) do 
	--Adds every preset song into the MusicTable except the player's chosen music.
	if v.Name ~= "CustomMusic" and v:IsA("Sound") then
		table.insert(MusicTable, v)
	end
end

local function Combine() --Combines all of the player's UIs into one table for easier reach in the future.
	for i, v in pairs(Drop:GetChildren()) do
		if v:IsA("Frame") then
			table.insert(UICombineTable, v)
		end
	end
	for i, v in pairs(RightSide:GetChildren()) do
		if v:IsA("Frame") then
			table.insert(UICombineTable, v)
		end
	end
	for i, v in pairs(Times:GetChildren()) do
		if v:IsA("Frame") then
			table.insert(UICombineTable, v)
		end
	end
	print(UICombineTable)
end

task.spawn(Combine)

local function DigitSizeConverter(Number) --Converts given number to it's desired named version (1000 = 1K).
	if Number >= 1e3 and Number < 1e6 then
		return "Thousand", "1e3", "K"
	elseif Number >= 1e6 and Number < 1e9 then
		return "Million", "1e6", "M"
	elseif Number >= 1e9 and Number < 1e12 then
		return "Billion", "1e9", "B"
	elseif Number >= 1e12 and Number < 1e15 then
		return "Trillion", "1e12", "T"
	elseif Number >= 1e15 and Number < 1e18 then
		return "Quadrillion", "1e15", "Q"
	elseif Number >= 1e18 and Number < 1 * 1e21 then
		return "Quintillion", "1e18", "Qu"
	elseif Number >= 1e21 and Number < 1e24 then
		return "Sextillion", "1e21", "Sx"
	elseif Number >= 1e24 and Number < 1e27 then
		return "Septillion", "1e24", "Se"
	elseif Number >= 1e27 and Number < 1e30 then
		return "Octillion", "1e27", "Oct"
	elseif Number >= 1e30 and Number < 1e33 then
		return "Nonillion", "1e30", "Non"
	elseif Number >= 1e33 and Number < 1e36 then
		return "Decillion", "1e33", "Dec"
	elseif Number >= 1e36 and Number < 1e39 then
		return "Undecillion", "1e36", "Und"
	elseif Number >= 1e39 and Number < 1e42 then
		return "Duodecillion", "1e39", "Duo"
	elseif Number >= 1e42 and Number < 1e45 then
		return "Tredecillion", "1e42", "Tre"
	elseif Number >= 1e45 and Number < 1e48 then
		return "Quattuordecillion", "1e45", "Quat"
	elseif Number >= 1e48 and Number < 1e51 then
		return "Quindecillion", "1e48", "Qui"
	elseif Number >= 1e51 and Number < 1e54 then
		return "Sexdecillion", "1e51", "Sxd"
	else
		return "", "1", ""
	end
end

local function Clicked() --Checks if the player has enough capital to drop the ball, and if yes then drops it.
	local WaitTime = 0
	local BoolWait = DropFrame.Wait

	if BoolWait.Value == true then return end

	local Cost = tonumber(CostInt.Name)
	print(Cost, leaderstats)
	local BCDrop, AllIn, SelectedSkin = CashDrop:InvokeServer(leaderstats, Cost) --Sends ball drop request to the server.

	if BCDrop then --Starts if the server says the player has enough capital.
		local RandomX = math.random(math.min(DownID.Position.X, UpperID.Position.X), math.max(DownID.Position.X, UpperID.Position.X))
		local RandomY = math.random(math.min(DownID.Position.Y, UpperID.Position.Y), math.max(DownID.Position.Y, UpperID.Position.Y))
		local RandomZ = math.random(math.min(DownID.Position.Z, UpperID.Position.Z), math.max(DownID.Position.Z, UpperID.Position.Z))
		--Finds random position based on the given parts' cordinates.

		local Ball = SelectedSkin:Clone()
		Ball.Parent = workspace.Balls
		if Ball:IsA("Model") then
			for i, v in pairs(Ball:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = false
				end
			end
		elseif Ball:IsA("Part") then
			Ball.Anchored = false
		end
		Ball:PivotTo(CFrame.new(RandomX, RandomY, RandomZ))
		Ball:AddTag("Ball")

		local Value = Instance.new("IntValue")
		Value.Parent = Ball
		Value.Name = Cost

		local StrVal = Instance.new("StringValue")
		StrVal.Parent = Ball
		StrVal.Name = 0
		
		if not Ball:IsA("Model") then
		if AllIn == 1 then --If the ball's value is near the full capital of the player then makes it have a gold outline.
			local Highlight = Instance.new("Highlight")
			Highlight.Parent = Ball
			Highlight.FillTransparency = 1
			Highlight.OutlineColor = Color3.fromRGB(212, 175, 75)
		else --Otherwise, it just has a red outline
			local Highlight = Instance.new("Highlight")
			Highlight.Parent = Ball
			Highlight.FillTransparency = 1
			Highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
		end
		end

		task.wait(WaitTime)
		BoolWait.Value = false
	end
	task.wait()
end

local function AutoDrop() --Automatically drops balls every 0.05s if turned on. Player can't manually drop balls if on.
	while true do
		if AutoDropEnabled.Value == true then
			task.spawn(Clicked)
		end
		task.wait(0.05)
	end
end

task.spawn(AutoDrop)

task.spawn(function()
	for i, v in pairs(DropFrame:GetChildren()) do
		if v:IsA("ImageButton") then
			v.MouseButton1Down:Connect(function() --If a drop button is clicked it activates.
				local SingleDrop = DropFrame:WaitForChild("SingleDrop")
				local TripleDrop = DropFrame:WaitForChild("TripleDrop")
				local Enabled = v.Parent.AutoDrop:WaitForChild("Enabled")

				if v.Name == SingleDrop.Name and Enabled.Value == false then --Drops only if auto drop is offline.
					task.spawn(Clicked)
				elseif v.Name == TripleDrop.Name and Enabled.Value == false then --Drops three at once if auto drop is off.
					for Count = 1, 3, 1 do
						task.spawn(Clicked)
						task.wait()
					end
				elseif v.Name == "AutoDrop" then 
				--If it's auto drop,then game turns manually dropping(single & triple drop)off. Changes button outlines.
					local Enabled = v:FindFirstChildOfClass("BoolValue")
					if Enabled.Value == true then --When disabling
						v.BackgroundColor3 = Color3.new(0,0,0)
						v.UIStroke.Color =  Color3.new(255,255,255)

						SingleDrop.BackgroundColor3 = Color3.new(255,255,255)
						SingleDrop.UIStroke.Color = Color3.new(0,0,0)
						TripleDrop.BackgroundColor3 = Color3.new(255,255,255)
						TripleDrop.UIStroke.Color = Color3.new(0,0,0)

						Enabled.Value = false
					elseif Enabled.Value == false then --When enabling
						v.BackgroundColor3 = Color3.new(255,255,255)
						v.UIStroke.Color =  Color3.new(0,0,0)

						SingleDrop.BackgroundColor3 = Color3.new(0,0,0)
						SingleDrop.UIStroke.Color = Color3.new(255,255,255)
						TripleDrop.BackgroundColor3 = Color3.new(0,0,0)
						TripleDrop.UIStroke.Color = Color3.new(255,255,255)

						Enabled.Value = true
					end
				end
			end)
		end
	end
end)

local function ChangePrice() --When the multiplier button is clicked it changes the required cash to drop a ball.
	for i, v in pairs(MainFrame:GetDescendants()) do
		if v:IsA("TextButton") and v:HasTag("TimesButton") then
			v.MouseButton1Down:Connect(function()
				local Times = v.Name --The X Button Clicked
				local CostValue = tonumber(CostInt.Name) --Cost of the IntValue.

				if Times == nil then return end
				local CashVal = tonumber(Cash.Name)
				local success, err = pcall(function()
					local ActualVal  --Before Cost * button clicked.
					if Times == "AllIn" then
						ActualVal = CashVal
					else
						ActualVal = CostValue * Times
					end
					local Size, ActualSize, ID = DigitSizeConverter(ActualVal)

					if CashVal >= ActualVal then --If the player has enough money per drop.
						if ActualVal >= 1 then --Makes sure it cant got below 1
							CostInt.Name = math.floor(ActualVal)
							CustomVal.Text = math.floor(ActualVal / ActualSize)..ID.."$"
							print(CostValue)
						elseif CostValue < 1 then
							CostInt.Name = 1
							CustomVal.Text = "1$"
						end
					else --if the player doesn't have enough, then it sets drop cost to the player's cash.
						local Size, ActualSize, ID = DigitSizeConverter(CashVal)
						CostInt.Name = math.floor(CashVal)
						local Num = CashVal / ActualSize..ID
						CustomVal.Text = math.floor(CashVal / ActualSize)..ID.."$"
						print(CostValue, Num)
					end
				end)
			end)
		end
	end

end

task.spawn(ChangePrice)

local function ChangeText() --Displays player's coins and gems on the UI, at the designated location (right side UI).
	while true do
		local Size, ActualSize, ID = DigitSizeConverter(tonumber(CostInt.Name))
		local CalcNum = tonumber(CostInt.Name) / ActualSize

		CostInt.Name = math.floor(CalcNum * ActualSize)

		if CashStr ~= nil and CoinsAmount ~= nil then
			CoinsAmount.Text = CashStr.Value
		end
		if Gems ~= nil and GemsAmount ~= nil then
			GemsAmount.Text = Gems.Value
		end
		task.wait()
	end
end

task.spawn(ChangeText)

local function CustomValEntered(functioning) --Changes drop cost depending on what the player types in.
	if CustomVal.Text == nil then CustomVal.Text = 1 return end
	local BeforeVal = tonumber(CostInt.Name)
	local DigitsOnly = string.gsub(CustomVal.Text, "[^%d]", "") --Removes all letters etc. from the box, only numbers stay.

	if #DigitsOnly == 0 or #DigitsOnly == nil then return end

	local Size, ActualSize, ID = DigitSizeConverter(tonumber(DigitsOnly))
	local CashVal = tonumber(Cash.Name)
	if tonumber(DigitsOnly) > tonumber(Cash.Name) then
		if CashVal < 1000 then
			CustomVal.Text = math.floor(CashVal).."$"
			CostInt.Name = math.floor(CashVal)
		else
			local Size, ActualSize, ID = DigitSizeConverter(tonumber(Cash.Name))
			local Num = CashVal / ActualSize
			CustomVal.Text = math.floor(CashVal / ActualSize)..ID.."$"
		end
	else
		local Num = DigitsOnly / ActualSize
		CustomVal.Text = math.floor(Num)..ID.."$"
		CostInt.Name = math.floor(DigitsOnly)
	end
end

local function Focused() 
--When the player clicks the custom drop cost box,it returns the text to integers instead of prefixes like "K", "M" etc.
	local Integers = string.gsub(CustomVal.Text, "[^%d]", "")
	local Letters = string.gsub(CustomVal.Text, "[^%a]", "")

	if Letters == "K" then
		CustomVal.Text = Integers * 1e3
	elseif Letters == "M" then
		CustomVal.Text = Integers * 1e6
	elseif Letters == "B" then
		CustomVal.Text = Integers * 1e9
	elseif Letters == "T" then
		CustomVal.Text = Integers * 1e12
	elseif Letters == "Q" then
		CustomVal.Text = Integers * 1e15
	elseif Letters == "Qu" then
		CustomVal.Text = Integers * 1e18
	else
		print("Number < 1000!")
	end
end

CustomVal.Focused:Connect(Focused)
CustomVal.FocusLost:Connect(CustomValEntered)

local function WarningTween(MSG)
	--Shows a warning sign on the top when funcion called with the desired message. 
	local Forward = {}
	Forward.Position = UDim2.fromScale(0.397, 0.07)

	local Inward = {}
	Inward.Position = UDim2.fromScale(0.397, -0.1)
	if WarningOngoing ~= true and MSG ~= nil then
		--Only tween settings and setting warning message here.
		WarningOngoing = true
		print(MSG)
		local Message = MSG
		print(WarningReq)
		WarningText.Text = tostring(Message)

		local TI = TweenInfo.new(2, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out)
		local Tween1 = TS:Create(Warning, TI, Forward)

		Tween1:Play()
		Tween1.Completed:Wait()
		task.wait(0.5)
		local TI2 = TweenInfo.new(2, Enum.EasingStyle.Cubic, Enum.EasingDirection.In)
		local Tween2 = TS:Create(Warning, TI2, Inward)

		Tween2:Play()
		Tween2.Completed:Wait()
		task.wait(0.5)
		WarningOngoing = false
	end
	task.wait(0.05)
end

local function OpenRebirthFrame() --Makes rebirth frame visible, other unrequired stuff invisible.
	for i, v in pairs(UICombineTable) do
		if v.Name ~= MRebFrame and v.Name ~= RebirthFrame and not v:HasTag("DC") then --DC = "Don't Close".
			v.Visible = false
		end
	end
	MRebFrame.Visible = true
	RebirthFrame.Visible = true
	Cost.Text = "Loading.."
	InvServ = true
	local RebCost = CostDisplayer:InvokeServer(Rebirths.Value)
	local Size, ActualSize, ID = DigitSizeConverter(RebCost)
	Cost.Text = "Rebirth Cost: "..RebCost / ActualSize..ID
	InvServ = false
end

RFrameOpener.MouseButton1Down:Connect(OpenRebirthFrame)

local function CloseRebirthFrame() --Makes rebirth frame invisible, makes other required stuff visible.
	for i, v in pairs(UICombineTable) do
		if v.Name ~= MRebFrame and v.Name ~= RebirthFrame and not v:HasTag("MF") then --MF = "Main Frame".
			v.Visible = true
		end
	end
	MRebFrame.Visible = false
	RebirthFrame.Visible = false

	Cost.Text = "Loading.."
end

Close.MouseButton1Down:Connect(CloseRebirthFrame)

local function RebirthClicked() --Sends a rebirth proposal to the server, deletes all currently dropped balls.
	local Success = Rebirthed:InvokeServer()
	print(Success)
	if Success then
		task.spawn(CloseRebirthFrame)
		for i, v in pairs(game.Workspace.Balls:GetChildren()) do
			if v:IsA("Part") then
				v:Destroy()
			end
		end
	else
		Fail:Play()
		task.spawn(WarningTween, "!Not Enough Cash!")
	end
end

RebirthButton.MouseButton1Down:Connect(RebirthClicked)

local function PlayMusic() --Always plays music automatically except if told not to.
	while Play do
		if Muted.Value or MusicPlaying then return end
		MusicPlaying = true
		local ChosenMusicID = math.random(1, #MusicTable)
		local ActualMusic = MusicTable[ChosenMusicID]

		if MusicRemoved ~= nil then
			table.insert(MusicTable, MusicRemoved)
		end
		if Muted.Value == false then
			ActualMusic:Play()
			ActualMusic.Ended:Wait()
		end
		MusicRemoved = ActualMusic
		table.remove(MusicTable, ChosenMusicID)
		MusicPlaying = false
		task.wait(0.1)
	end
end

task.spawn(PlayMusic)

local function StopMusic(ToFalse) --Stops every music if function called.
	for i, v in pairs(MusicGroup:GetChildren()) do
		v:Stop()
	end
	if ToFalse ~= nil then
		MusicPlaying = false
	end
end

local function PurchaseClicked() --Makes buying items from the shop possible.
	for i, v in pairs(ShopFrame:GetChildren()) do
		if v:IsA("Frame") then
			for o, b in pairs(v:GetChildren()) do
				if b:IsA("TextButton") then
					b.MouseButton1Down:Connect(function()
						local Button = b
						local ItemClass = b.Parent.ItemClass.Value
						local ItemName = b.Parent.ItemsName.Value

						local Bought, ItemType = BuyingItem:InvokeServer(ItemName, ItemClass)--Sends buy request to server.
						
						if Bought and ItemType == "!" then --If item is a case then:
							task.spawn(function()
								for i, v in pairs(UICombineTable) do
									if v.Name ~= AcquiredItem and not v:HasTag("DC") then 
										--Closes everything except important frames.
										v.Visible = false
									end
								end
								AcquiredItem.Visible = true --Makes the opened item visible.
							end)
							TimeRemaining.Value = 40
						end
					end)
				end
			end
		end
	end
end

task.spawn(PurchaseClicked)

local function OpenShop() 
	--Makes the shop visible and everything else invisible, except DC frames. (Frames like DropFrame).
	for i, v in pairs(UICombineTable) do
		if v.Name ~= Shop and not v:HasTag("DC") then
			v.Visible = false
		end
	end
	Shop.Visible = true
end

ShopOpener.MouseButton1Down:Connect(OpenShop)

local function CloseShop() --Makes the shop invisible and everyhing else visible, except MF frames (Frames like rebirth).
	for i, v in pairs(UICombineTable) do
		if v.Name ~= Shop and not v:HasTag("MF") then
			v.Visible = true
		end
	end
	Shop.Visible = false
end

ShopExit.MouseButton1Down:Connect(CloseShop)

--MF = MainFrame, DC = Don't Close

PaymentChecker.OnClientEvent:Connect(function(Timer, Pay) --Displays remaining time until free cash receivement.
	--Fires upon server message
	if Timer ~= nil then
		local Minutes = math.floor(Timer / 60)
		local Seconds = Timer % 60
		if Seconds < 10 then
			PaymentTimer.Text = Minutes..":0"..Seconds.." till receiving "..Pay.."."
		else
			PaymentTimer.Text = Minutes..":"..Seconds.." till receiving "..Pay.."."
		end
	end
end)

local Val

local function UpdateValue() --Updates music volume when slider triggered.
	local BGSize = math.round(CurrentValue.Value, 1)
	local TI = TweenInfo.new(0.25, Enum.EasingStyle.Exponential)

	Val = math.clamp(((Vector2.new(Mouse.X, Mouse.Y) - Slider.AbsolutePosition) / Slider.AbsoluteSize).X, 0, MaxLoudness/100)
	--Gets the new volume from the mouse's position on the slider's X axis.

	if CurrentValue.Value ~= Val then --If the volume's amount has changed.
		TS:Create(Object, TI, {Size = UDim2.fromScale(Val, 1)}):Play()
	end
	CurrentValue.Value = Val

	task.spawn(function()
		for i, v in pairs(MusicGroup:GetChildren()) do
			if Val * 100 > 4 then --If volume above 4% then changes volume to the new amount.
				Muted.Value = false
				Object.Visible = true
				v.Volume = Val
				VolumePercentage.Text = tostring(math.round(Val * 100).."%")
				MuteState.Image = "rbxassetid://78808995729959"
				if not MusicPlaying then
					task.spawn(PlayMusic)
				else
				end
			else --Else mutes the sound. Without it would be hard or impossible to fully mute.
				Muted.Value = true
				VolumePercentage.Text = "0%"
				MuteState.Image = "rbxassetid://118458820765098"
				Object.Visible = false
				v.Volume = 0
			end
		end
	end)
end

local function Activate() --When function called it calls the UpdateValue function while Go == true.
	Go.Value = true
	while Go.Value == true do
		UpdateValue()
		task.wait()
	end
end

Trigger.MouseButton1Down:Connect(Activate)

game:GetService("UserInputService").InputEnded:Connect(function(input) 
	--Sets Go's value false when player stops interacting with slider.
	local error, success = pcall(function()
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			Go.Value = false
			if Val * 100 < 4 then
				Muted.Value = true
				MuteState.Image = "rbxassetid://118458820765098"
				Object.Visible = false
				task.spawn(StopMusic, true)
			else
				Muted.Value = false
				MuteState.Image = "rbxassetid://78808995729959"
				Object.Visible = true
				if not MusicPlaying then
					task.spawn(PlayMusic)
				end
			end
		end
	end)
end)

SettingsOpener.MouseButton1Down:Connect(function() --Makes settings frame visible and everything invisible, except DCs.
	task.spawn(function()
		for i, v in pairs(UICombineTable) do
			if v.Name ~= Settings and not v:HasTag("DC") then
				v.Visible = false
			end
		end
		Settings.Visible = true
	end)
end)

SettingsExit.MouseButton1Down:Connect(function()--Makes settings frame invisible and everything visible,except MFs and DCs.
	task.spawn(function()
		for i, v in pairs(UICombineTable) do
			if v.Name ~= Settings and not v:HasTag("MF") and not v:HasTag("DC") then
				v.Visible = true
			end
		end
		Settings.Visible = false
	end)
end)

MusicChooser.MouseButton1Down:Connect(function() --When player wants to choose between preset songs, makes songs visible.
	MusicsFrame.Visible = true
	MusicChooser.Visible = false
	CustomMusicID.Visible = false
	Play = true
end)

local HappenedBefore = false
local BackMsg = false
local Stop = false

local MusicButtons = {}

task.spawn(function() --Inserts instances inside of the "MusicScroll" instance into the MusicButtons table (TextButtons).
	for i, v in pairs(MusicsScroll:GetChildren()) do
		if v:IsA("Frame") then
			for o, b in pairs(v:GetChildren()) do
				if b:IsA("TextButton") then
					table.insert(MusicButtons, b)
				end
			end
		end
	end
end)

local OngoingCustom = false
local CanTrue = true

local function MusicSelected(MusicName, Induced) --When function called stops every music, then start chosen music.
	MusicsFrame.Visible = false
	CustomMusicID.Visible = true
	MusicChooser.Visible = true
	MusicChooser.Text = "Playing: "..MusicName
	task.spawn(StopMusic)
	local Music

	HappenedBefore = true --Tells other functions that MusicSelected has been called before.
	for p, n in pairs(MusicGroup:GetChildren()) do
		if n.Name == MusicName then
			n:Play() --Finds chosen music and starts it.
			Music = n
			table.remove(MusicTable, p) --Removes chosen music from the table temporarily.
			MusicPlaying = true
		end
	end
	while Music.IsPlaying and not Stop do --Waits until music finished or force stopped.
		task.wait()
	end
	if not Stop then --Start auto play if function didn't get force stopped.
		task.spawn(PlayMusic)
	end
	MusicPlaying = false
	BackMsg = true --
	table.insert(MusicTable, Music)
	--Puts previous music back into circulation later, so auto play doesn't choose it immediately again.
	if CanTrue then
		Play = true
	end
	if Induced ~= nil then
		task.wait(0.05)
		task.spawn(PlayMusic)
	end
end

task.spawn(function()
	for i, v in pairs(MusicButtons) do
		v.MouseButton1Down:Connect(function() --When music chosen, stops auto playing other songs.
			Play = false
			MusicPlaying = true
			if not HappenedBefore then --If not happened before then stops all songs and calls MusicSelected.
				StopMusic(true)
				MusicPlaying = true
				task.spawn(MusicSelected, v.Parent:FindFirstChildOfClass("StringValue").Value, true)
			else --If happened before then force stops MusicSelected fuction with Stop = true.
				Stop = true 
				while not BackMsg do --Waits until music stopped.
					task.wait()
				end
				BackMsg = false --Turns BackMsg to default again.
				Stop = false --Returns force stop off.
				StopMusic(true) --Stops all songs.
				MusicPlaying = true
				task.spawn(MusicSelected, v.Parent:FindFirstChildOfClass("StringValue").Value, true)
			end
			task.wait(0.05)
		end)
	end
end)

local KeepPlaying = true

local function CustomIDEntered() --Fires when custom music ID is entered.
	CustomMusicID.ClearTextOnFocus = false
	local ClearedInput = string.gsub(CustomMusicID.Text, "[^%d]", "")
	local success, error = pcall(function()
		return MPS:GetProductInfo(tonumber(ClearedInput), Enum.InfoType.Asset) --Checks if song ID exists.
	end)
	if success and ClearedInput ~= "" then
		task.spawn(StopMusic)
		CustomMusic:Stop()
		CustomMusic.SoundId = "rbxassetid://"..ClearedInput
		CustomMusic:Play()
		KeepPlaying = true
		while CustomMusic.IsPlaying and KeepPlaying do
			task.wait()
		end
		if KeepPlaying then
			Play = true
			MusicPlaying = false
			task.wait(0.05)
			local Playing = false
			for i, v in pairs(MusicGroup:GetChildren()) do
				if v.IsPlaying then
					Playing = true
				end
			end
			if not Playing then
				task.spawn(PlayMusic)
			end
		end
	end
end

CustomMusicID.FocusLost:Connect(function() --Fires CustomIDEntered function when player stops typing.
	CanTrue = false
	Play = false
	MusicPlaying = true

	KeepPlaying = false
	task.spawn(CustomIDEntered)
end)

local function OthersVisibleSet() --Fires when player changes others' visibility setting.
	task.spawn(function()
		if PlayersVisible.Value == true then --Fires is player is turning other's invisible
			SeePlayers.Image = "rbxassetid://106859401548430"
			SeePlayers.HoverImage = "rbxassetid://90597686545345"
			SeePlayersText.Text = "Others: Invisible"
			CanSeePlayers:FireServer(false) --Sends message to make others invsibile.
			task.wait(0.1)
			while PlayersVisible.Value == false do --Runs while visibility is set to off.
				for i, v in pairs(game.Players:GetPlayers()) do
					if v.Name ~= Player.Name then
						local PlrModel = game.Workspace:FindFirstChild(v.Name)
						for o, b in pairs(PlrModel:GetDescendants()) do 
							--Makes all parts invisible by turning transparency to 1.
							local success, error = pcall(function()
								return b["Transparency"]
							end)
							if success then
								b["Transparency"] = 1
							end
						end
					end
				end
				task.wait(2.5)
			end
		elseif PlayersVisible.Value == false then --Fires is player is turning other's visible.
			SeePlayers.Image = "rbxassetid://89579396494700"
			SeePlayers.HoverImage = "rbxassetid://123984061053177"
			SeePlayersText.Text = "Others: Visible"
			CanSeePlayers:FireServer(true)
			task.wait(0.1)
			while PlayersVisible.Value == true do --Runs while visibility is set to on.
				for i, v in pairs(game.Players:GetPlayers()) do
					if v.Name ~= Player.Name then
						local PlrModel = game.Workspace:FindFirstChild(v.Name)
						for o, b in pairs(PlrModel:GetDescendants()) do
							--Makes all parts visible by turning transparency to 0.
							if b.Name ~= "HumanoidRootPart" then
								local success, error = pcall(function()
									return b["Transparency"]
								end)
								if success then
									b["Transparency"] = 0
								end
							end
						end
					end
				end
				task.wait(2.5)
			end
		end
	end)
end

SeePlayers.MouseButton1Down:Connect(OthersVisibleSet)

local MovingTheFrame = false

local function CheckIfClicked(ItemFrame, MovingFrame, Folder, Bool) 
	--Plays one of the two tweens depending on the chosen tween direction.
	local Sound = MovingFrame.Sound
	if not Bool then --Plays if player wants to make skin infos visible.
		local Goal = {}
		Goal.Position = UDim2.fromScale(0, 0.2)

		local TI = TweenInfo.new(2, Enum.EasingStyle.Linear)
		local Tween = TS:Create(MovingFrame, TI, Goal)

		Tween:Play()
		Sound:Play()
	elseif Bool then --Plays if player wants to make skin infos invisible.
		local Goal = {}
		Goal.Position = UDim2.fromScale(0, -1)

		local TI = TweenInfo.new(2, Enum.EasingStyle.Linear)
		local Tween = TS:Create(MovingFrame, TI, Goal)

		Tween:Play()
		Sound:Play()
	end
end

InventoryOpener.MouseButton1Down:Connect(function()
	--Makes the Inventory visible and everything else invisible, except DC and MF frames.
	for i, v in pairs(UICombineTable) do
		if v.Name ~= Inventory and not v:HasTag("MF") and not v:HasTag("DC") then
			v.Visible = false
		end
	end
	Inventory.Visible = true
end)

InventoryExit.MouseButton1Down:Connect(function()
	--Makes the Inventory invisible and everyhing else visible, except MF and DC frames.
	task.spawn(function()
		for i, v in pairs(UICombineTable) do
			if v.Name ~= Inventory and not v:HasTag("MF") and not v:HasTag("DC") then
				v.Visible = true
			end
		end
		Inventory.Visible = false
	end)
end)

task.spawn(function() 
	--When different item type selector button gets clicked in the inventory then it changes to that item type in the inv.
	for i, v in pairs(Inventory.Buttons:GetChildren()) do
		if v:IsA("TextButton") then
			v.MouseButton1Down:Connect(function()
				local FrameName = v:GetTags() -- Tag = Item Type.

				for i, v in pairs(Inventory:GetChildren()) do
					if v.Name == FrameName[1] and v:IsA("Frame") then --If item types match.
						for i, v in pairs(Inventory:GetChildren()) do--Makes every other item type invis except chosen one.
							if v:IsA("Frame") and not v:HasTag("ButtonFrame") then
								v.Visible = false
							end
						end
						v.Visible = true --Makes chosen item type visible in the inventory.
					end
				end
			end)
		end
	end
end)

task.spawn(function()
	--Sends the server a message when player changes ball skin
	for i, v in pairs(Inventory.SkinsFrame.ScrollingFrame:GetChildren()) do
		if v:IsA("ImageButton") then
			v.MouseButton1Down:Connect(function()
				if v.Taken.Value == true then --If there is an equippable skin in that "Skin Slot".
					BallSkinSelecting:FireServer(v.ItemsName.Value) --Sends server a message to change the equipped skin.
				end
			end)
		end
	end
end)

local function MusicChecker() 
	--Checks if multiple songs are playing at the same time by error, or stops other songs if custom song chosen.
	while true do
		if CustomMusic.IsPlaying then --Stops all other songs if there's a custom music chosen.
			for i, v in pairs(MusicTable) do
				if v.Name ~= CustomMusic.Name then
					v:Stop()
				end
			end
		else 
			--[[If no chosen custom music, then checks if multiple songs are playing at once by accident.
			If yes, fixes and chooses new music]]
			local Counter = 0

			for i, v in pairs(MusicTable) do --Checks all song instances in the MusicTable (Table with song instances.).
				if v.Playing then
					Counter += 1
				end
			end
			if Counter > 1 then --If multiple songs are playing at once then stops every song and restarts the system.
				StopMusic("NotNil")
				task.spawn(PlayMusic)
			end
		end

		task.wait(1)
	end
end

task.spawn(MusicChecker)

task.spawn(function()
	while true do --Checks every 1/20th second if opened crate's item UI is meant to disappear or not.
		task.wait(0.05)
		if TimeRemaining.Value > 1 then
			TimeRemaining.Value -= 1
		elseif TimeRemaining.Value == 1 then --If it's time to disappear then:
			task.spawn(function()
				for i, v in pairs(UICombineTable) do --Makes everything visible except MFs and opened item's frame.
					if v.Name ~= AcquiredItem and not v:HasTag("MF") then
						v.Visible = true
					end
				end
				AcquiredItem.Visible = false --Sets opened item's frame invisible.
			end)
			TimeRemaining.Value -= 1
		else --If TimeRemaining = 0 or less than 0 then makes sure the opened item's frame is invisible.
			AcquiredItem.Visible = false
		end
	end
end)


--StarterPlayer -> StarterPlayerScripts, "MainPlrScript"

local RS = game:GetService("ReplicatedStorage")
local CashRetreiver = RS:WaitForChild("CashRetreiver")
local SendVals = RS:WaitForChild("SendVals")
local DebrisLaunch = RS:WaitForChild("DebrisLaunch")

local CashTable = {}

local function BallValChecker() --Gets the player's money in balls and sends it.
	while true do
		local TotalVal = 0
		for i, v in	pairs(game.Workspace.Balls:GetChildren()) do
			if v:IsA("Part") then
				local Value = v:FindFirstChildOfClass("IntValue", true)
				if Value then
					TotalVal += Value.Name
				end
			end
		end
		SendVals:FireServer(TotalVal)
		task.wait(0.05)
	end
end

task.spawn(BallValChecker)

local RS = game:GetService("ReplicatedStorage")
local GiveCash = RS:WaitForChild("GiveCash")

local function BallMultiplier()
	--When the ball touches a multiplier it sends the ball's value and multiplier's value to the server.
	while true do
		for i, v in pairs(game.Workspace.Balls:GetChildren()) do
			if v:HasTag("Ball") then
				local PartToCheck = nil
				if v:IsA("BasePart") then
					--print("aaaa")
					PartToCheck = v
				else 
					--print("aaaa")
					PartToCheck = v:FindFirstChildOfClass("BasePart") or v:FindFirstChildOfClass("UnionOperation")
				end
				--print(PartToCheck)
				if PartToCheck ~= nil then
					local TObj = workspace:GetPartsInPart(PartToCheck)
					for o, b in pairs(TObj) do
						if b:HasTag("MultiplierBlock") then
							local Multiplier = b.Name
							local Value
							if v:FindFirstChildOfClass("IntValue") then
								Value = v:FindFirstChildOfClass("IntValue").Name
								v:Destroy()
								GiveCash:FireServer(Multiplier, Value)
							end
						end
					end
				end
			end
		end
		task.wait()
	end
	task.wait(1)
end

task.spawn(BallMultiplier)

local function BallTimeChecker()
	--Checks if a ball has been in the workspace for too long, and if yes then makes it disappear and refund's the price.
	--Made to dodge potential ball's getting stuck issues
	while true do
		for i, v in pairs(workspace.Balls:GetChildren()) do
			if v:IsA("Part") then
				local StrVal = v:FindFirstChildOfClass("StringValue")
				local IntVal = v:FindFirstChildOfClass("IntValue")

				if tonumber(StrVal.Name) >= 10 then
					v:Destroy()
					DebrisLaunch:FireServer(tonumber(IntVal.Name))
				else 
					StrVal.Name += 1
				end
			end
		end
		task.wait(1)
	end
end

task.spawn(BallTimeChecker)
