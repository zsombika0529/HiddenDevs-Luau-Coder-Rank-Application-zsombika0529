--Server Script Service, "Leaderstats"

local ContentProvider = game:GetService("ContentProvider")
local RS = game:GetService("ReplicatedStorage")
local CashRetreiver = RS.CashRetreiver
local SendVals = RS.SendVals
local BuyingItem = RS.BuyingItem
local CanSeePlayers = RS.CanSeePlayers
local BallSkinSelecting = RS:WaitForChild("BallSkinSelecting")

local DSS = game:GetService("DataStoreService")
local CashDS = DSS:GetDataStore("Cash")

local CashTable = {}

local PriceTable = { --G = Costs Gems, C = Costs Coins, . = Item, ! = Crate.
	BallSkinCrate = "25G!",
	CommonPlinkoTheme = "100000C.",
	CommonPotion = "1000000C."
}

local ImagesTable = { --All of the items' image IDs
	BallSkinCrate = "rbxassetid://77242011109894",
	CommonPlinkoTheme = "rbxassetid://121697505281461",
	CommonPotion = "rbxassetid://17637751963",
	SmoothRed = "rbxassetid://83081996979885",
	SmoothYellow = "rbxassetid://124101355972353",
	SmoothWhite = "rbxassetid://125160088029436",
	SmoothBrown = "rbxassetid://135245582866344",
	ClassicGrey = "rbxassetid://97063688680159",
	BlackMarble = "rbxassetid://77799025248012",
	BronzeMarble = "rbxassetid://76912381811994",
	GrossMarble = "rbxassetid://131724383613299",
	WhiteMarble = "rbxassetid://90216881716216",
	Rust1 = "rbxassetid://116897317688724",
	Rust2 = "rbxassetid://85979031794679",
	Rust3 = "rbxassetid://140128218873968",
	Rust4 = "rbxassetid://75648348548468",
	BloodyBall = "rbxassetid://118844611319134",
	BrownNeon = "rbxassetid://81542463535698",
	GreenNeon = "rbxassetid://113271166489872",
	PinkNeon = "rbxassetid://100135961043608",
	PukeBall = "rbxassetid://113271166489872",
	RedNeon = "rbxassetid://1334395022041449",
	SandBall = "rbxassetid://81521259496800",
	SnowBall = "rbxassetid://135804439049002",
	BlueMetal = "rbxassetid://87253186589944",
	BlueFoil = "rbxassetid://92221039790252",
	CyanMetal = "rbxassetid://104653597627296",
	GreenFoil = "rbxassetid://71921610838778",
	GreenMetal = "rbxassetid://111936388898319",
	PurpleFoil = "rbxassetid://88827627271835",
	YellowMetal = "rbxassetid://74865220120905",
	YellowFoil = "rbxassetid://82744091520648",
	CapsuledCoal = "rbxassetid://121220277074747",
	GreenForcefield = "rbxassetid://99502572209951",
	PinkForcefield = "rbxassetid://85963245088448",
	RedForcefield = "rbxassetid://77811793913912",
	SmoothBlack = "rbxassetid://125075668458760",
	SmoothCyan = "rbxassetid://90103584690996",
	SmoothGreen = "rbxassetid://107381301169800",
	YellowForcefield = "rbxassetid://131207805992599",
	BlueCoin = "rbxassetid://97063688680159",
	BrownCoin = "rbxassetid://97063688680159",
	Developers = "rbxassetid://97063688680159",
	Joelen2010Var1 = "rbxassetid://97063688680159",
	Joelen2010Var2 = "rbxassetid://97063688680159",
	RedCoin = "rbxassetid://97063688680159",
	YellowCoin = "rbxassetid://97063688680159",
	zsombika0529 = "rbxassetid://97063688680159",
	Blackhole = "rbxassetid://97063688680159",
	Carbon = "rbxassetid://97063688680159",
	Chlorophyll = "rbxassetid://97063688680159",
	EarthnMoon = "rbxassetid://97063688680159",
	NeutronStar = "rbxassetid://97063688680159",
	Oxygen = "rbxassetid://97063688680159",
	SolarSystem = "rbxassetid://97063688680159",
	Sulfur = "rbxassetid://97063688680159"
}

local ClassTable = { --3 = Ball skins, Potions = 2, Plinko Themes = 1.
	BallSkinCrate = 3,
	CommonPlinkoTheme = 1,
	CommonPotion = 2,
	SmoothRed = 3,
	SmoothYellow = 3,
	SmoothWhite = 3,
	SmoothBrown = 3,
	ClassicGrey = 3,
	BlackMarble = 3,
	BronzeMarble = 3,
	GrossMarble = 3,
	WhiteMarble = 3,
	Rust1 = 3,
	Rust2 = 3,
	Rust3 = 3,
	Rust4 = 3,
	BloodyBall = 3,
	BrownNeon = 3,
	GreenNeon = 3,
	PinkNeon = 3,
	PukeBall = 3,
	RedNeon = 3,
	SandBall = 3,
	SnowBall = 3,
	BlueMetal = 3,
	BlueFoil = 3,
	CyanMetal = 3,
	GreenFoil = 3,
	GreenMetal = 3,
	PurpleFoil = 3,
	YellowMetal = 3,
	YellowFoil = 3,
	CapsuledCoal = 3,
	GreenGlass = 3,
	PinkGlass = 3,
	RedGlass = 3,
	SmoothBlack = 3,
	SmoothCyan = 3,
	SmoothGreen = 3,
	YellowGlass = 3,
	BlueCoin = 3,
	BrownCoin = 3,
	Developers = 3,
	Joelen2010Var1 = 3,
	Joelen2010Var2 = 3,
	RedCoin = 3,
	YellowCoin = 3,
	zsombika0529 = 3,
	Blackhole = 3,
	Carbon = 3,
	Chlorophyll = 3,
	EarthnMoon = 3,
	NeutronStar = 3,
	Oxygen = 3,
	SolarSystem = 3,
	Sulfur = 3
}

local BallSkins = workspace:WaitForChild("BallSkins")

game.Players.PlayerAdded:Connect(function(Plr) --Starts multiple future commands upon player joining.
	local leaderstats = Instance.new("Folder")
	leaderstats.Parent = Plr
	leaderstats.Name = "leaderstats"

	local CashStr = Instance.new("StringValue")
	CashStr.Parent = leaderstats
	CashStr.Name = "Cash"
	CashStr.Value = 100

	local Cash = Instance.new("IntValue")
	Cash.Parent = Plr
	Cash.Name = 100

	local Gems = Instance.new("IntValue")
	Gems.Name = "Gems"
	Gems.Parent = leaderstats
	Gems.Value = 0

	local Rebirths = Instance.new("IntValue")
	Rebirths.Name = "Rebirths"
	Rebirths.Parent = leaderstats
	Rebirths.Value = 0

	local Timer = Instance.new("IntValue")
	Timer.Parent = Plr.PlayerGui
	Timer.Name = "Timer"
	Timer.Value = 60

	local MoneyCap = Instance.new("IntValue")
	MoneyCap.Parent = Plr.PlayerGui
	MoneyCap.Name = 1e6
	MoneyCap:AddTag("MC")

	local Settings = Instance.new("Folder")
	Settings.Parent = Plr
	Settings.Name = "Settings"

	local PlayersVisible = Instance.new("BoolValue")
	PlayersVisible.Parent = Settings
	PlayersVisible.Name = "PlayersVisible"
	PlayersVisible.Value = true

	local SelectedBallSkin = Instance.new("StringValue")
	SelectedBallSkin.Parent = Settings
	SelectedBallSkin.Name = "SelectedBallSkin"
	SelectedBallSkin.Value = "ClassicGrey"

	local Inventory = Instance.new("Folder")
	Inventory.Parent = Plr
	Inventory.Name = "Inventory"
	--Makes default places to load all Player data, and for future gameplay.
	local Data

	local success, err = pcall(function() --Loads basic player data.
		Data = CashDS:GetAsync(Plr.UserId)

		if Data.SelectedBallSkin ~= nil then
			SelectedBallSkin.Value = Data.SelectedBallSkin
		end
		if Data.Cash == nil or Data.Cash == 0 then
			Cash.Name = 100
			CashStr.Value = 100
			
			if Data.Gems ~= nil and Data.Rebirths ~= 0 then
				Gems.Value = Data.Gems
			end

			if Data.Rebirths ~= nil and Data.Rebirths ~= 0 then --You can only have gems if you've rebirthed before!
				Rebirths.Value = Data.Rebirths
			end
		else
			Cash.Name = math.floor(Data.Cash)
			CashStr.Value = math.floor(Data.Cash)
			
			if Data.Gems ~= nil and Data.Rebirths ~= 0 then
				Gems.Value = Data.Gems
			end

			if Data.Rebirths ~= nil and Data.Rebirths ~= 0 then
				Rebirths.Value = Data.Rebirths
			end
		end
		local BallSkins = workspace:WaitForChild("BallSkins")
		if Data.Inventory then --Checks if Player had previous Themes/Potions/Ball Skins.
			for i, v in pairs(Data.Inventory) do
				local AddItem = Instance.new("StringValue")
				AddItem.Parent = Inventory
				AddItem.Value = v
			end
			for i, v in pairs(BallSkins:WaitForChild("Default"):GetChildren()) do
				--Checks if Player is missing default skins, just in case.
				local Found = false
				for o, b in pairs(Inventory:GetChildren()) do
					if v.Name == b.Value then
						Found = true
					end
				end
				if not Found then
					local AddItem = Instance.new("StringValue")
					AddItem.Parent = Inventory
					AddItem.Value = v.Name
				end
			end
		else --If no previous data then adds default skins into the Player's inventory.
			for i, v in pairs(BallSkins:WaitForChild("Default"):GetChildren()) do 
				--Adds default skins to Player's if no previous data.
				local AddItem = Instance.new("StringValue")
				AddItem.Parent = Inventory
				AddItem.Value = v.Name
			end
		end
			for i, v in pairs(Inventory:GetChildren()) do
				local ImgID = nil
				for o, b in pairs(ImagesTable) do --Goes through the table and finds the skin's picture.
					if o == v.Value then
						ImgID = b
						break
					end
				end
				if ImgID ~= nil then
					local Class = tonumber(ClassTable[v.Value])

					local InventoryUI = Plr:WaitForChild("PlayerGui"):WaitForChild("RightSide"):WaitForChild("Inventory")
					local Inventory2ndClass

					if Class == 1 then --Finds the place to put the loaded item to.
						Inventory2ndClass = InventoryUI.ThemesFrame
					elseif  Class == 2 then
						Inventory2ndClass = InventoryUI.PotionsFrame
					elseif Class == 3 then
						Inventory2ndClass = InventoryUI.SkinsFrame
					end
					if Class == nil or Inventory2ndClass == nil then return end
					local ScrollingFrame = Inventory2ndClass:FindFirstChildOfClass("ScrollingFrame")
					for o, b in pairs(ScrollingFrame:GetChildren()) do --Adds the owned skins into the player's inventory.
						if b:IsA("ImageButton") then
							local Taken = b:FindFirstChildOfClass("BoolValue")
							if not Taken.Value then --If the place in the inventory is free.
								Taken.Value = true
								b:FindFirstChildOfClass("StringValue").Value = v.Value

								local ImageLabel = b:FindFirstChildOfClass("ImageLabel")
								ImageLabel:FindFirstChildOfClass("UIStroke").Enabled = true

								if ImageLabel ~= nil and ImgID then
									ImageLabel.Image = ImgID
								end
								break
							end
						end
					end
				end
			end
	end)
	print(err, success)
	if not success and Data ~= nil then --Kicks if failed to load (doesn't kick if no previous data).
		--task.wait(4)
		print("aaaaa")
		Plr:Kick("Error loading data. Please rejoin and try again.")
		print("Didn't load")
	else --Gives "LoadedSuccessfully" tag if succeeded (Tag needed for many various future functions).
		print("Yea we good")
		Plr:AddTag("LoadedSuccessfully")
	end

	local function CanBuy(Plr, ItemName, ItemClass) --Checks if the player can afford the requested item.
		print("Got it!", ItemName)
		local CashInt = Plr:FindFirstChildOfClass("IntValue", true)
		local Gems = Plr:FindFirstChild("leaderstats", true):FindFirstChild("Gems", true)

		if PriceTable[ItemName] == nil then return "Item Not Found" end
		local PriceString = PriceTable[ItemName]
		print(PriceString, string.gsub(PriceString, "[^%d]", ""), string.gsub(PriceString, "[^%a]", ""))
		local CrateCost = string.gsub(PriceString, "[^%d]", "")
		local CrateCurrency = string.gsub(PriceString, "[^%a]", "")
		local ItemType = string.gsub(PriceString, "[^%.%!]", "")
		local NonSpecifiedCurrencyAmount

		if CrateCurrency == "G" then
			NonSpecifiedCurrencyAmount = Gems.Value
			CrateCurrency = 2
		elseif CrateCurrency == "C" then
			NonSpecifiedCurrencyAmount = CashInt.Name
			CrateCurrency = 1
		end
		
		if tonumber(NonSpecifiedCurrencyAmount) >= tonumber(CrateCost) then
			if CrateCurrency == 1 then
				CashInt.Name -= CrateCost
			elseif CrateCurrency == 2 then
				Gems.Value -= CrateCost
			end
			local InventoryFolder = Plr:WaitForChild("Inventory")
			
			if ItemType == "." then --Adds the normal item into the player's inventory.
				local NewItem = Instance.new("StringValue")
				NewItem.Parent = InventoryFolder
				NewItem.Value = ItemName
			elseif ItemType == "!" then --If ! then it's a crate, rolls the crate.
				local RightSide = Plr:WaitForChild("PlayerGui", 3):WaitForChild("RightSide", 3)
				local AcquiredItem = RightSide:WaitForChild("AcquiredItem", 3)
				local ItemImage = AcquiredItem:WaitForChild("ItemImage", 3)
				local GottenItemName = AcquiredItem:WaitForChild("GottenItemName", 3)
				local ItemRarity = AcquiredItem:WaitForChild("ItemRarity", 3)
				local TimeRemaining = AcquiredItem:WaitForChild("TimeRemaining", 3)
				
				local RandInt = math.random(0, 10000)
				local GottenNum = RandInt/100
				local GottenRarity
				if GottenNum <= 0.5 then
					GottenRarity = "Mythic"
					ItemRarity.TextColor3 = Color3.fromRGB(230, 30, 30)
				elseif GottenNum <= 3 then
					GottenRarity = "Legendary"
					ItemRarity.TextColor3 = Color3.fromRGB(255, 128, 0)
				elseif GottenNum <= 10 then
					GottenRarity = "Epic"
					ItemRarity.TextColor3 = Color3.fromRGB(163, 53, 238)
				elseif GottenNum <= 25 then
					GottenRarity = "Rare"
					ItemRarity.TextColor3 = Color3.fromRGB(0, 112, 221)
				elseif GottenNum <= 50 then
					GottenRarity = "Uncommon"
					ItemRarity.TextColor3 = Color3.fromRGB(30, 255, 0)
				else
					GottenRarity = "Common"
					ItemRarity.TextColor3 = Color3.fromRGB(128, 128, 128)
				end
				local SkinRarityTable = BallSkins:FindFirstChild(GottenRarity):GetChildren()
				local SkinRarityIndex = math.random(1, #SkinRarityTable)
				local OpenedSkin = SkinRarityTable[SkinRarityIndex]
				print(GottenRarity, SkinRarityTable[SkinRarityIndex])
				ItemName = OpenedSkin.Name
				
				AcquiredItem.Visible = true
				
				ItemRarity.Text = GottenRarity
				GottenItemName.Text = OpenedSkin.Name
				ItemImage.Image = ImagesTable[ItemName]
				
				local Inventory = Plr.Inventory
				local AddItem = Instance.new("StringValue")
				AddItem.Parent = Inventory
				AddItem.Value = OpenedSkin.Name
			end

			--[[How to use: Make a new stringval, its value needs to be the item's name.
				Place it in the "InventoryFolder". Then copy the rest of the code.]]

			task.spawn(function() --Puts the item into the player's openable inventory UI.
				local PlrGui = Plr.PlayerGui
				local RightSide = PlrGui.RightSide
				local Inventory = RightSide.Inventory

				local Inventory2ndClass

				if ItemClass == "1" then
					Inventory2ndClass = Inventory.ThemesFrame
				elseif  ItemClass == "2" then
					Inventory2ndClass = Inventory.PotionsFrame
				elseif ItemClass == "3" then
					Inventory2ndClass = Inventory.SkinsFrame
				end
				local ScrollingFrame = Inventory2ndClass:FindFirstChildOfClass("ScrollingFrame")

				for i, v in pairs(ScrollingFrame:GetChildren()) do
					if v:IsA("ImageButton") then
						local Taken = v:FindFirstChildOfClass("BoolValue")
						if not Taken.Value then
							Taken.Value = true
							v:FindFirstChildOfClass("StringValue").Value = ItemName
							local ImageLabel = v:FindFirstChildOfClass("ImageLabel")
							ImageLabel:FindFirstChildOfClass("UIStroke").Enabled = true

							local Img = ImagesTable[ItemName]

							ImageLabel.Image = Img
							break
						end
					end
				end
			end)
			return true, ItemType
		elseif tonumber(NonSpecifiedCurrencyAmount) < tonumber(CrateCost) then
			return false
		end
	end

	BuyingItem.OnServerInvoke = CanBuy

	local PlrGui = Plr.PlayerGui
	local RightSide = PlrGui:WaitForChild("RightSide")
	local Shop = RightSide:WaitForChild("Shop")
	local ShopFrame = Shop:WaitForChild("ShopFrame")
end)

local function SafeSave() --Failsave, saves every players' data every 30s just in case if an error were to occur.
	while true do
		for i, v in pairs(game.Players:GetPlayers()) do
			if v:HasTag("LoadedSuccessfully") then
				local InventoryItems = v:FindFirstChild("Inventory")

				local ExtraCash = 0
				for o, b in pairs(CashTable) do
					if v.Name == b.Name then
						ExtraCash = b.Value
					end
				end

				local DSSTable = {}
				for o, b in pairs(InventoryItems:GetChildren()) do
					table.insert(DSSTable, b.Value)
				end
				local DataToSave = {
					Cash = tonumber(v:FindFirstChildOfClass("IntValue", true).Name) + ExtraCash,
					Rebirths = v:FindFirstChild("leaderstats", true):FindFirstChild("Rebirths").Value,
					Gems = v:FindFirstChild("leaderstats", true):FindFirstChild("Gems", true).Value,
					Inventory = DSSTable --Inventory (skins).
				}
				local success, result = pcall(function()
					return CashDS:UpdateAsync(v.UserId, function(OldData)
						return DataToSave or OldData --If no data to save, then saves the previous data again.
					end)
				end)
				print(result, success, "Saved for: "..v.Name)
			else
				print("Couldn't load.")
			end
		end
		task.wait(10)
	end
end

task.spawn(SafeSave)

SendVals.OnServerEvent:Connect(function(Plr, Value)
	--Puts the player's current money found in balls to save if the player were to suddenly leave.
	local Found = false
	for i, v in pairs(CashTable) do
		if v.Name == Plr.Name then --If already in the table then remove the previous data and readd new data.
			table.remove(CashTable, i)
			table.insert(CashTable, {Name = Plr.Name, Value = Value})
			Found = true
		end
	end
	if Found == false then --If not in the table then just add in normally.
		table.insert(CashTable, {Name = Plr.Name, Value = Value})
	end
end)

CanSeePlayers.OnServerEvent:Connect(function(Plr, Answer) --Turns on or off if the player can see others (out of order).
	local Settings = Plr:FindFirstChild("Settings")
	local PlayersVisible = Settings:FindFirstChild("PlayersVisible")

	if PlayersVisible.Value == true then --To Invis
		PlayersVisible.Value = false
	elseif PlayersVisible.Value == false then --To Vis
		PlayersVisible.Value = true
	end
end)

local success = true

game.Players.PlayerRemoving:Connect(function(Plr) --Saves players' data when they leave the experience.
	local InventoryItems = {}

	for i, v in pairs(Plr.Inventory:GetChildren()) do --Gets all player's inventory items and puts it in a table.
		if v:IsA("StringValue") and v.Value ~= nil then
			table.insert(InventoryItems, v.Value)
		end
	end
	if Plr:HasTag("LoadedSuccessfully") then --If successfully loaded at the beggining of joining then let's the game save.
		local ExtraCash = 0
		for i, v in pairs(CashTable) do
			if v.Name == Plr.Name then
				ExtraCash = v.Value
			end
		end
		local DataToSave = {
			Cash = tonumber(Plr:FindFirstChildOfClass("IntValue", true).Name) + ExtraCash,
			Rebirths = Plr:FindFirstChild("leaderstats", true):FindFirstChild("Rebirths").Value,
			Gems = Plr:FindFirstChild("leaderstats", true):FindFirstChild("Gems", true).Value,
			Inventory = InventoryItems,
			SelectedBallSkin = Plr.Settings.SelectedBallSkin.Value
		}
		local success, result = pcall(function()
			return CashDS:UpdateAsync(Plr.UserId, function(OldData)
				print(DataToSave)
				return DataToSave or OldData --If new data to save then saves, otherwise saves the previous data again.
			end)
		end)
	end
	task.wait()
end)

BallSkinSelecting.OnServerEvent:Connect(function(Plr, SkinName) --Changes the player's selected ball skin upon request.
	for i, v in pairs(Plr.Inventory:GetChildren()) do
		if v.Value == SkinName then
			Plr.Settings.SelectedBallSkin.Value = SkinName
		end
	end
end)


--StarterPlayer -> StarterPlayerScripts, "MainPlrScript"

local RS = game:GetService("ReplicatedStorage")
local CashRetreiver = RS:WaitForChild("CashRetreiver")
local SendVals = RS:WaitForChild("SendVals")
local DebrisLaunch = RS:WaitForChild("DebrisLaunch")

local CashTable = {}

local function BallValChecker() --Gets the player's money in balls and sends it.
	while true do
		local TotalVal = 0
		for i, v in	pairs(game.Workspace.Balls:GetChildren()) do
			if v:IsA("Part") then
				local Value = v:FindFirstChildOfClass("IntValue", true)
				if Value then
					TotalVal += Value.Name
				end
			end
		end
		SendVals:FireServer(TotalVal)
		task.wait(0.05)
	end
end

task.spawn(BallValChecker)

local RS = game:GetService("ReplicatedStorage")
local GiveCash = RS:WaitForChild("GiveCash")

local function BallMultiplier()
	--When the ball touches a multiplier it sends the ball's value and multiplier's value to the server.
	while true do
		for i, v in pairs(game.Workspace.Balls:GetChildren()) do
			if v:HasTag("Ball") then
				local PartToCheck = nil
				if v:IsA("BasePart") then
					--print("aaaa")
					PartToCheck = v
				else 
					--print("aaaa")
					PartToCheck = v:FindFirstChildOfClass("BasePart") or v:FindFirstChildOfClass("UnionOperation")
				end
				--print(PartToCheck)
				if PartToCheck ~= nil then
					local TObj = workspace:GetPartsInPart(PartToCheck)
					for o, b in pairs(TObj) do
						if b:HasTag("MultiplierBlock") then
							local Multiplier = b.Name
							local Value
							if v:FindFirstChildOfClass("IntValue") then
								Value = v:FindFirstChildOfClass("IntValue").Name
								v:Destroy()
								GiveCash:FireServer(Multiplier, Value)
							end
						end
					end
				end
			end
		end
		task.wait()
	end
	task.wait(1)
end

task.spawn(BallMultiplier)

local function BallTimeChecker()
	--Checks if a ball has been in the workspace for too long, and if yes then makes it disappear and refund's the price.
	--Made to dodge potential ball's getting stuck issues
	while true do
		for i, v in pairs(workspace.Balls:GetChildren()) do
			if v:IsA("Part") then
				local StrVal = v:FindFirstChildOfClass("StringValue")
				local IntVal = v:FindFirstChildOfClass("IntValue")

				if tonumber(StrVal.Name) >= 10 then
					v:Destroy()
					DebrisLaunch:FireServer(tonumber(IntVal.Name))
				else 
					StrVal.Name += 1
				end
			end
		end
		task.wait(1)
	end
end

task.spawn(BallTimeChecker)
